# 🎯 load-more 事件监听使用说明

## ✨ 新特性 (v1.0.2+)

现在推荐使用**事件监听**方式处理数据加载，替代全局函数方式！

---

## 📝 为什么使用事件监听？

### ✅ 事件监听的优势

1. **符合标准**: 使用原生 DOM 事件，不污染全局命名空间
2. **类型安全**: TypeScript 完美支持，有完整的类型提示
3. **更清晰**: 代码组织更好，不依赖全局变量
4. **现代化**: 符合现代前端框架的使用习惯

### ❌ 全局函数的问题

```javascript
// ❌ 旧方式：需要全局函数
window.loadMore = function(component) { ... }
```

- 污染全局命名空间
- 容易命名冲突
- 不符合模块化开发
- TypeScript 支持较差

---

## 🚀 快速开始

### 原生 JavaScript

```html
<waterfall-flow id="waterfall" row-gap="10" column-gap="10">
  <!-- 内容 -->
</waterfall-flow>

<script>
  const waterfall = document.getElementById('waterfall');
  
  waterfall.addEventListener('load-more', (event) => {
    // 📌 重要：阻止默认行为
    event.preventDefault();
    
    // 获取事件数据
    const { currentCount, finishLoading } = event.detail;
    
    console.log(`当前有 ${currentCount} 个项目`);
    
    // 加载数据
    fetch('/api/items?page=' + currentPage)
      .then(res => res.json())
      .then(data => {
        // 添加新项目
        data.items.forEach(item => {
          const el = createItem(item);
          waterfall.appendChild(el);
        });
        
        // 📌 必须：通知加载完成
        finishLoading(data.hasMore); // true = 还有更多，false = 没有了
      });
  });
</script>
```

### Vue 3 / Nuxt 4

```vue
<template>
  <waterfall-flow
    @load-more="handleLoadMore"
    :row-gap="10"
    :column-gap="10"
  >
    <div v-for="item in items" :key="item.id">
      {{ item.title }}
    </div>
  </waterfall-flow>
</template>

<script setup>
import { ref } from 'vue';
import 'wj-waterfall-flow';

const items = ref([]);
const currentPage = ref(0);

const handleLoadMore = async (event) => {
  const { currentCount, finishLoading } = event.detail;
  
  currentPage.value++;
  
  try {
    const response = await fetch(`/api/items?page=${currentPage.value}`);
    const data = await response.json();
    
    items.value.push(...data.items);
    
    // 通知加载完成
    finishLoading(data.hasMore);
  } catch (error) {
    console.error('加载失败:', error);
    finishLoading(false);
  }
};
</script>
```

### React

```jsx
import { useEffect, useRef, useState } from 'react';
import 'wj-waterfall-flow';

function WaterfallDemo() {
  const [items, setItems] = useState([]);
  const waterfallRef = useRef(null);
  const currentPageRef = useRef(0);

  useEffect(() => {
    const waterfall = waterfallRef.current;
    if (!waterfall) return;

    const handleLoadMore = async (event) => {
      const { currentCount, finishLoading } = event.detail;
      
      currentPageRef.current++;
      
      try {
        const response = await fetch(`/api/items?page=${currentPageRef.current}`);
        const data = await response.json();
        
        setItems(prev => [...prev, ...data.items]);
        
        finishLoading(data.hasMore);
      } catch (error) {
        console.error('加载失败:', error);
        finishLoading(false);
      }
    };

    waterfall.addEventListener('load-more', handleLoadMore);

    return () => {
      waterfall.removeEventListener('load-more', handleLoadMore);
    };
  }, []);

  return (
    <waterfall-flow ref={waterfallRef} row-gap="10" column-gap="10">
      {items.map(item => (
        <div key={item.id}>{item.title}</div>
      ))}
    </waterfall-flow>
  );
}
```

---

## 📚 API 详解

### 事件：`load-more`

当组件需要加载更多数据时触发。

**事件对象** (`CustomEvent`)

```typescript
interface LoadMoreDetail {
  // 当前已有的项目数量
  currentCount: number;
  
  // 完成加载的回调函数
  finishLoading: (hasMore: boolean) => void;
}

event.detail: LoadMoreDetail
```

**重要提示：**

1. ✅ **必须调用 `event.preventDefault()`**，告诉组件你正在处理事件
2. ✅ **必须调用 `finishLoading(hasMore)`**，通知组件加载完成
   - `finishLoading(true)` - 还有更多数据
   - `finishLoading(false)` - 没有更多数据了

---

## 💡 最佳实践

### 1. 错误处理

```javascript
waterfall.addEventListener('load-more', async (event) => {
  event.preventDefault();
  const { finishLoading } = event.detail;
  
  try {
    const data = await fetchData();
    // ... 处理数据
    finishLoading(data.hasMore);
  } catch (error) {
    console.error('加载失败:', error);
    // 发生错误时，标记为无更多数据
    finishLoading(false);
  }
});
```

### 2. 加载状态管理 (Vue)

```vue
<script setup>
const isLoading = ref(false);

const handleLoadMore = async (event) => {
  isLoading.value = true;
  const { finishLoading } = event.detail;
  
  try {
    const data = await fetchData();
    items.value.push(...data.items);
    finishLoading(data.hasMore);
  } finally {
    isLoading.value = false;
  }
};
</script>
```

### 3. 防抖处理

```javascript
let loadingTimeout;

waterfall.addEventListener('load-more', (event) => {
  event.preventDefault();
  const { finishLoading } = event.detail;
  
  // 清除之前的加载
  clearTimeout(loadingTimeout);
  
  loadingTimeout = setTimeout(async () => {
    const data = await fetchData();
    // ... 处理数据
    finishLoading(data.hasMore);
  }, 300);
});
```

---

## ⚠️ 常见问题

### Q1: 数据一直重复加载？

**原因**: 没有调用 `finishLoading()` 或者没有调用 `event.preventDefault()`

```javascript
// ❌ 错误
waterfall.addEventListener('load-more', (event) => {
  loadData(); // 忘记调用 finishLoading
});

// ✅ 正确
waterfall.addEventListener('load-more', (event) => {
  event.preventDefault(); // 1. 阻止默认行为
  const { finishLoading } = event.detail;
  
  loadData().then(data => {
    // ... 处理
    finishLoading(true); // 2. 通知完成
  });
});
```

### Q2: 为什么要调用 `event.preventDefault()`？

因为组件会检查事件是否被阻止，如果没有阻止，说明没有监听器处理，组件会尝试调用全局函数作为后备。

```javascript
// 组件内部逻辑
this.dispatchEvent(event);

if (!event.defaultPrevented) {
  // 没有监听器，尝试全局函数
  window[onLoadMore]?.();
}
```

### Q3: Vue 中 `@load-more` 不生效？

确保：
1. 组件正确导入：`import 'wj-waterfall-flow'`
2. 在 Nuxt 中使用 `<ClientOnly>` 包裹
3. 事件名是 `load-more`（kebab-case）

```vue
<!-- ✅ 正确 -->
<waterfall-flow @load-more="handleLoadMore">

<!-- ❌ 错误 -->
<waterfall-flow @loadMore="handleLoadMore">
```

### Q4: React 中事件监听不生效？

检查：
1. 使用 `useEffect` 添加监听器
2. 清理函数正确移除监听器
3. `ref` 正确绑定到组件

```jsx
useEffect(() => {
  const el = waterfallRef.current;
  if (!el) return; // ⚠️ 检查 ref 是否存在
  
  const handler = (e) => { /* ... */ };
  el.addEventListener('load-more', handler);
  
  return () => el.removeEventListener('load-more', handler);
}, []); // ⚠️ 依赖数组为空
```

---

## 🔄 向后兼容

旧的全局函数方式仍然支持，但**不推荐使用**：

```html
<!-- 旧方式（不推荐） -->
<waterfall-flow onLoadMore="loadMore"></waterfall-flow>
<script>
  window.loadMore = function(component) {
    // ...
  };
</script>

<!-- 新方式（推荐） -->
<waterfall-flow id="waterfall"></waterfall-flow>
<script>
  document.getElementById('waterfall')
    .addEventListener('load-more', (event) => {
      // ...
    });
</script>
```

---

## 📖 TypeScript 支持

完整的类型定义：

```typescript
import type { WaterfallFlowElement, LoadMoreDetail } from 'wj-waterfall-flow';

const waterfall = document.getElementById('waterfall') as WaterfallFlowElement;

waterfall.addEventListener('load-more', (event: CustomEvent<LoadMoreDetail>) => {
  const { currentCount, finishLoading } = event.detail;
  // 完整的类型提示 ✨
});
```

---

## 🎉 总结

**推荐使用事件监听方式：**

1. ✅ Vue: `@load-more="handleLoadMore"`
2. ✅ React: `addEventListener('load-more', handler)`
3. ✅ 原生: `waterfall.addEventListener('load-more', handler)`

**记住两个要点：**

1. 📌 调用 `event.preventDefault()`
2. 📌 调用 `finishLoading(hasMore)`

祝您使用愉快！🚀

